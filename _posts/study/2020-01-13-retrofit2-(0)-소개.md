---
categories: 
  - study
tags:
   - Retrofit2
---

<p>오늘은 <a href="https://square.github.io/retrofit/">Retrofit2</a>에 대해서 간단히 겉핥기로 알아보고자 한다.</p>
<p><strong>Retrofit2</strong>는 안드로이드 개발자가 http 서버와 통신 하는 작업을 쉽고, 빠르고, 안전하게 사용 할 수 있게 해주는 라이브러리로, <a href="https://square.github.io/okhttp/">OkHttp</a>와 더불어 대표적인 http통신 라이브러리이다.</p>
<h1 id="개요">1. 개요</h1>
<p>Retrofit는 HTTP API를 자바 인터페이스로 변환하는 역할을 수행한다.</p>
<pre><code>public  interface  GitHubService  {  
    @GET("users/{user}/repos")  
    Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path("user")  String user);  
}
</code></pre>
<p><code>Retrofit</code> 클래스를 이용하여 <code>GitHubService</code> 인터페이스의 구현을 할 수 있다.</p>
<pre><code>Retrofit retrofit =  new  Retrofit.Builder()  
    .baseUrl("https://api.github.com/")  
    .build();
    
GitHubService service = retrofit.create(GitHubService.class);
</code></pre>
<p>생성된 <code>GitHubService</code>로 부터의 <code>Call</code>은 웹 서버로 비동기/동기적인 HTTP 요청을 전송한다.</p>
<p>HTTP 요청을 설명하기 위해 아래의 annotations을 이용할 수 있다.</p>
<ul>
<li>URL parameter 교체</li>
<li>query parameter 지원</li>
<li>Object를 request body로 변환</li>
<li>Multipart로 구성된 body나 파일 업로드</li>
</ul>
<h1 id="api-선언">2. API 선언</h1>
<p>인터페이스 메소드나, 매개 변수에 어노테이션으로 요청을 처리하는 방법에 대한 기술.</p>
<h2 id="request-method">Request Method</h2>
<p>모든 메소드는 요청 메소드와 URL에 대한 HTTP 어노테이션이 필요하다.<br>
이에 5개의 내장 어노테이션이 존재하는데, 이는 GET, POST, PUL, DELETE, HEAD이다.</p>
<pre><code>@GET("users/list")
// 물론 URL에 매개 변수를 명시할 수 있다.
@GET("users/list?sort=desc")
</code></pre>
<h2 id="url-조작">URL 조작</h2>
<p>아래와 같이 요청하려는 URL을 동적으로 지정 할 수 있다.</p>
<pre><code>@GET("group/{id}/users")
Call&lt;List&lt;User&gt;&gt; groupList(@Path("id")  int groupId);
</code></pre>
<p>기본적으로 위처럼 정적 변수를 입력할 수도 있지만, 쿼리 매개 변수를 사용하여 동적으로 할당하는 것도 가능하다.</p>
<h2 id="request-body">Request body</h2>
<p>HTTP 요청의 본문에 <code>@body</code> 어노테이션을 이용해 명시할 수 있다.</p>
<pre><code>@POST("users/new")
Call&lt;User&gt; createUser(@Body  User user);
</code></pre>
<h2 id="form-encoded와-multipart">Form encoded와 Multipart</h2>
<p>Form-encoded data나 Multipart data를 이용해 선언할 수도 있다.</p>
<p>Form-encoded 데이터는 <code>FormUrlEncoded</code>가 현재 메소드에 존재할 때 사용된다.</p>
<pre><code>@FormUrlEncoded
@POST("user/edit")
Call&lt;User&gt; updateUser(@Field("first_name")  String first,  @Field("last_name")  String  last);
</code></pre>
<p>Multipart 요청은 <code>@Multipart</code>가 현재 메소드에 존재할 때 사용된다,</p>
<pre><code>@Multipart 
PUT("user/photo")  
Call&lt;User&gt; updateUser(@Part("photo")  RequestBody photo,  @Part("description")  RequestBody description);
</code></pre>
<h2 id="header-조작">Header 조작</h2>
<pre><code>@Headers({  
    "Accept: application/vnd.github.v3.full+json",  
    "User-Agent: Retrofit-Sample-App"  })  
@GET("users/{username}")
Call&lt;User&gt; getUser(@Path("username")  String username);
</code></pre>
<p>동적 헤더는 <code>@Headers</code> 어노테이션을 이용하여 선언 할 수 있다.</p>
<p>같은 이름을 가진 헤더끼리도 서로 덮어씌우지 않고, 각각 요청에 포함된다.</p>
<p><code>@Header</code>이 null이면 헤더를 생략한다.</p>
<h2 id="동기식-vs-비동기식">동기식 vs 비동기식</h2>
<p><code>call</code> 인스턴스는 enqueue를 사용하여 비동기식으로 실행하거나, excute를 사용하여 동기식으로 선택하여 실행할 수 있다.<br>
각 인스턴스는 한 번만 사용할 수 있지만, <code>clone()</code>를 호출하여 새 인스턴스를 생성한 후, 사용할 수 있다.</p>
<h1 id="장점">3. 장점</h1>
<ul>
<li>빠른 속도, 안정성.</li>
<li>쉽게 설치하고, 사용할 수 있다.</li>
<li>어노테이션을 사용하여 직관적이고, 가독성이 뛰어나다.</li>
<li>플러그인 형태를 취하고 있어, 유지보수에 편하다.</li>
</ul>
<h1 id="단점">4. 단점</h1>
<ul>
<li>타 라이브러리에 비해 추가기능이 많은 편은 아니다.</li>
<li>OkHttp의 상위에서 구현된 라이브러리로, 기본적으로 OkHttp에 의존적이다. <sub>(사실 OkHttp도 매우 좋은 라이브러리로, 그다지 단점은 아님)</sub></li>
</ul>

