---
categories:
  - Algorithm
tags:
  - Programmers
---
# [숫자 게임 PGs#12987](https://programmers.co.kr/learn/courses/30/lessons/12987)

<details>
<summary><b>Python 코드 보기</b></summary>
<div markdown="1">

```python
def solution(A, B):
    A.sort()
    B.sort()
    answer = 0
    aIdx = 0
    bIdx = 0
    
    while bIdx < len(B):
        if A[aIdx] < B[bIdx]:
            aIdx += 1
            bIdx += 1
            answer += 1
        else:
            bIdx += 1
    
    return answer
```

</div>
</details>

- - -

## ☝ 입력 형식

-   먼저 모든 사원이 무작위로 자연수를 하나씩 부여받습니다.
-   각 사원은 딱 한 번씩 경기를 합니다.
-   각 경기당 A팀에서 한 사원이, B팀에서 한 사원이 나와 서로의 수를 공개합니다. 그때 숫자가 큰 쪽이 승리하게 되고, 승리한 사원이 속한 팀은 승점을 1점 얻게 됩니다.
-   만약 숫자가 같다면 누구도 승점을 얻지 않습니다.

A 팀원들이 부여받은 수가 출전 순서대로 나열되어있는 배열 `A`와 i번째 원소가 B팀의 i번 팀원이 부여받은 수를 의미하는 배열 `B`가 주어집니다.

**제한사항**

-   `A`와  `B`의 길이는 같습니다.
-   `A`와  `B`의 길이는  `1`  이상  `100,000`  이하입니다.
-   `A`와  `B`의 각 원소는  `1`  이상  `1,000,000,000`  이하의 자연수입니다.

## 🤞 출력 형식

+ B 팀원들이 얻을 수 있는 최대 승점을 return 하도록 solution 함수를 완성해주세요.

## 🤟 구현 과정

### 1. 비교 방법 고민

B팀원이 가장 높은 승점을 받기 위해서는, 각각 A팀원을 이길 수 있는 가장 낮은 수로 이기는 경우가 많아져야한다.

A팀원이 1과 5를 가지고 있을 때, B팀원이 2, 100을 가지고 있다고 가정하자.
1을 이기기 위해 100을 내는 행동은 비효율적이다.

그렇다면 A팀원의 숫자를 이기기 위한 가장 작은 수를 찾는 과정을 구현하면 될 것이다.

### 2. 구체화

각각의 숫자 비교는 두 경우로 나누어 질 것이다.

1. B팀의 승리
	- A사원의 수 보다 B사원의 수가 큰 경우
		-> 다음 A사원과 다음 B사원이 대결
		-> **aIdx**와 **bIdx** 모두 **+1**씩
		-> B팀이 승리했으므로, `answer += 1`
3. B팀의 승리 외의 경우 (A승리 + 무승부)
		-> 현재 B사원이 이길 수 있는 A사원을 검색
		-> **aIdx**만 **+1**


