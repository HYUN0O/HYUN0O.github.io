---
categories: 
   - study
tags:
   - Kotlin
   - Rx
---

갑작스럽게 안드로이드 개발을 시작하면서 온전히 내가 만든 코드가 아닌, 선임자가 만들고 간 코드를 분석하고 해석하며 개발에 입문하였다.

대부분의 개발 과정에서는 선임자의 코드를 약간씩 변형하고, 필요한 니즈에 맞춰 변수나 파라미터를 수정하는 정도 선에서 해결할 수 있었다. 완전히 새로운 영역의 개발이 필요하거나 하는 문제가 없었으나, 1년차 꼬꼬마 개발자에게 **Rx**는 높은 벽이였다.

물론 아직도 **Rx**를 이해하고 활용하기에는 너무나도 배움이 부족하고, 경험이 적다. 

그래도 아무 것도 모르던 때 구글링해서 글만 읽던 때 보다는 다시 정리하며 얻어갈 부분이 더 있으리라고 생각하여, 이 쯤에서 한번 다시 배우고 가는 시간을 가지려고 한다.

## Map Operator

우선, Rx의 기본은 Obserable과 Subscribe, 그 다음은 **Map**을 통한 데이터 가공 및 전달이라고 생각한다.

> **Map**은 또 뭔데 씹덕아!

라고 한다면, *Observable로 수신한 데이터를 새로운 형태로 가공하는데 쓰이는 것* 이라고 쓰여있기는 하다.

분명 맞는 말이고 정확하지만 조금 더 쉽게 표현하자면 **단순한 함수(function)**와 거의 비슷하다.

차이점이라면, 수신하는 데이터의 **흐름**에 대응하여 처리한다는 차이점이 존재하기에, **흐름에 대응하는 방식**에 따라 크게 4가지의 함수로 나뉜다는 점이다.



### 1. Map()

![사진1](https://github.com/danggai/danggai.github.io/blob/master/assets/image/20200921/01.png?raw=true)

가장 기본이 되는 Map이다. 이름부터 우리가 흔히 사용하던 "매핑"과 같은 뜻으로 직관적인 기능을 갖는 함수다.
(사진의 하얀 부분 (map{○ --> ◇}) 은 어떤 input를 바탕으로 값을 변환하는 과정)

수신한 데이터를 바탕으로 어떤 작업을 수행 후, 결과를 return하는 간단한 함수와 같은 역할을 한다. 기존에 사용하던 **lambda의 그것**을 생각하면 편하다.

후술하겠지만, `Map()`은 수신한 데이터를 가공하여 데이터로 반환하지만, 다른 Map Operator들은 수신한 데이터를 가공하여 **데이터 내 각각의 아이템을 각각의 Observable**로 반환한다는 차이점이 존재한다. 



모든 함수가 놀랍게도 **지연 시간이 없거나**, 모든 데이터가 예쁘게도 **함수가 작동 중이지 않을 때만 수신**된다면 좋겠지만, 바빠 죽겠는데 수신되는 ~~눈치 없는~~ 데이터들도 분명히 존재한다.

그 때는 아래 후술할 3가지의 Map Operator을 통해 데이터의 처리 방식과 순서를 원하는 대로 컨트롤 할 수 있다. 



### 2. FlatMap()

![사진2](https://github.com/danggai/danggai.github.io/blob/master/assets/image/20200921/02.png?raw=true)

그림을 보면 초록 동그라미의 수신 후, 결과 값의 반환이 **종료 되지 않았음에도** 파란 동그라미를 수신하고, 파란 동그라미에 대한 **결과 값을 반환하기 시작**한다.

또한, 그림에는 나와있지 않지만 오히려 **먼저 수신한 데이터가 더 늦게 작업이 종료**될 수도 있다.

이는 `FlatMap()`을 통해 결과 값으로 만들어진 각각의 Observable들은 각각의 Lifecycle를 지니기에, **데이터의 순서를 신경쓰지 않는다**는 처리방식에서 발생하는 특징이다.



`FlatMap()`부터는 위에서 언급한 `Map()`과는 다르게, Observable형으로 데이터를 반환하는데, 이는 데이터의 흐름을 자연스럽게 유지하는 데 용이하다는 사용 상의 차이점을 낳는다. 



### 3. ConcatMap()

![사진3](https://github.com/danggai/danggai.github.io/blob/master/assets/image/20200921/03.png?raw=true)

그림을 보면, `FlatMap()`과는 다르게, 초록 동그라미의 **결과 값의 반환이 종료되기 전에** 파란 동그라미라는 데이터를 수신하였을 때, 초록 동그라미를 **마저 완료하고** 파란 동그라미를 **처리하는 것**을 확인할 수 있다.

`FlatMap()`과 거의 비슷하게 각각의 Observable들이 각각의 Lifecycle를 지니지만, 이전에 수신한 데이터가 아직 처리중이라면, 종료 시까지 기다리는 특징을 갖는다.

데이터의 **수신 주기가 일정하지 않고**, 데이터 **처리 소요 시간이 길지 않다**면 **적합**한 선택지이겠지만, 데이터의 수신 주기가 짧고, 데이터의 처리가 오래 걸리는 작업이라면 오히려 끔찍한 성능을 보여줄 것이다.

하지만, 모든 데이터의 **순서를 따르는 안전한 처리가 보장되어야 하는 경우**에는 선택해 볼만한 선택지로 작용할 것이다.



### 4. SwitchMap()

![사진4](https://github.com/danggai/danggai.github.io/blob/master/assets/image/20200921/04.png?raw=true)

그림을 보면, `FlatMap()`과는 다르게, 초록 동그라미의 **결과 값의 반환이 종료되기 전에** 파란 동그라미라는 데이터를 수신하였을 때, 초록 동그라미의 **처리를 중지하고** 파란 동그라미를 **처리하는 것**을 확인할 수 있다.

중간 과정보다는 **마지막 값의 결과**만이 중요할 때 선택할 수 있는 선택지이다.

우리 주변에서는 **검색**, **비밀번호 유효성 검사** 등이 SwitchMap()을 대표하는 가장 흔한 예시이다.



## 참고 사이트

  - [reactivex.io](http://reactivex.io/RxJava/javadoc/io/reactivex/Flowable.html#flatMap-io.reactivex.functions.Function-)